binary search
	left, right := 0, len(nums)-1
	for left < right {
		mid := (left + right) /2

		if nums[mid] == n 
			return 
		if nums[mid] > n
			right = mid-1
		else 
			left = mid+1
	}

	hints: divide & conqur

find Maximum in sliding Window
	when finding max or min, instead of using max() / min()
	use heap if the number is greater than 2

	hints: heap
	is it required to store all the elements of current window?

	using queue

find k in rotated sorted array
	033
	for left < right {
		mid := (left + right) / 2

		if nums[mid] == k {
			return mid
		}

		if nums[left] <= nums[mid] {
			// this can be done as binary search
			if k >= nums[left] && k < nums[mid] {
				right = mid - 1
			} else {
				left = mid + 1
			}
		} else {
			if k > nums[mid] && k <= nums[right] {
				left = mid + 1
			} else {
				right = mid - 1
			}
		}
	}
	if nums[left] == k {
		return left
	}
	return -1

find min value in rotate sorted array
	153
	for left < right {
		mid := (left + right) / 2
		if nums[mid] > nums[right] {
			left = mid + 1
		} else {
			right = mid
		}
	}

find the 1st bad version
	L, R := 0, len(vers)-1
	for L <= R {
		M := (L + R) / 2

		// fmt.Printf("%v L %d M %d R %d\n", vers, L, M, R)
		if vers[M] == true {
			R = M - 1
		} else {
			L = M + 1
		}
	}


